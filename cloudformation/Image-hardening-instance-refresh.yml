#
# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: MIT-0
#
# Permission is hereby granted, free of charge, to any person obtaining a copy of this
# software and associated documentation files (the "Software"), to deal in the Software
# without restriction, including without limitation the rights to use, copy, modify,
# merge, publish, distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
# INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
# PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
# HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
AWSTemplateFormatVersion: '2010-09-09'
Description: EC2 Image Builder Pipeline for ECS Optimized Image with Ansible playbook

Parameters:
  AnsiblePlaybookBucket:
    Type: String
    Description: Enter S3 bucket name of where you store your Ansible playbook

  AnsiblePlaybookArguments:
    Type: String
    Description: Enter extra arguments you want to pass to 'ansible-playbook' command. (Advanced)
    Default: ""

  LatestECSOptimizedAMI:
    Description: AMI ID, defaults to latest ECS Optimized AL2 image. 
    Type: AWS::SSM::Parameter::Value<AWS::EC2::Image::Id>
    Default: /aws/service/ecs/optimized-ami/amazon-linux-2/recommended/image_id

  InstanceType:
    Description: Insance type used with EC2 Image Builder Infrastructure Configuration
    Type: String
    Default: t2.small
  
  RootVolumeSize:
    Description: Enter the desired Volume size (GiB) of root EBS block
    Type: Number
    Default: 30
    MinValue: 1
    MaxValue: 16000

  RootVolumeType:
    Description: Enter the desired Volume type of root EBS block
    Type: String
    Default: gp3
    AllowedValues:
      - gp2
      - gp3
      - io1
      - io2
      - sc1
      - st1
      - standard

  libDockerVolumeSize: 
    Description: Enter desired Volume size (GiB) of EBS block where /var/lib/docker is mounted 
    Type: Number
    Default: 30
    MinValue: 1
    MaxValue: 16000

  libDockerVolumeType:
    Description: Enter desired Volume type of EBS block where /var/lib/docker is mounted 
    Type: String
    Default: gp3
    AllowedValues:
      - gp2
      - gp3
      - io1
      - io2
      - sc1
      - st1
      - standard
  
  ComponentName:
    Description: EC2 Image Builder Component Name
    Type: String
    Default: ECSAnsibleComponent

  RecipeName:
    Description: EC2 Image Builder Recipe Name
    Type: String
    Default: ECSAnsibleRecipe

  InfrastructureConfigurationName:
    Description: EC2 Image Builder Infrastructure Configuration Name
    Type: String
    Default: ImageBuilderInfrastructureConfig

  DistributionConfigurationName:
    Description: EC2 Image Builder Distribution Configuration Name
    Type: String
    Default: ImageBuilderDistributionConfiguration

  ImagePipelineName:
    Description: EC2 Image Builder Image Pipeline Name
    Type: String
    Default: ECSAnsiblePipeline

  EnableImageScanning:
    Description: Enter true to enable Amazon Inspector scanning for your AMIs. Enter false to disable AMI scanning.
    Type: String
    Default: true
    AllowedValues:
      - true
      - false

  ClusterTags:
    Description: A JSON string containing the tags as a list of key-value pairs to filter ECS clusters
    Type: String
    Default: "[]"

  CloudFormationUpdaterEventBridgeRuleState:
    Description: EventBridge rule state. Rule runs every weekend and if there is a new base image, sends results to an SNS topic.
    Type: String
    Default: ENABLED
    AllowedValues:
      - DISABLED
      - ENABLED

Metadata: 
  AWS::CloudFormation::Interface: 
    ParameterGroups: 
      - Label:
          default: Ansible Configuration
        Parameters:
          - AnsiblePlaybookBucket
          - AnsiblePlaybookArguments
      - 
        Label: 
          default: AMI Configurations
        Parameters: 
          - LatestECSOptimizedAMI
          - InstanceType
          - RootVolumeSize
          - RootVolumeType
          - libDockerVolumeSize
          - libDockerVolumeType
      - Label:
          default: EC2 Image Builder Configurations
        Parameters:
          - ComponentName
          - RecipeName
          - InfrastructureConfigurationName
          - DistributionConfigurationName
          - ImagePipelineName
          - EnableImageScanning
      - Label:
          default: AMI Refresh Config
        Parameters:
          - ClusterTags
      - Label:
          default: Automation parameters
        Parameters:
          - CloudFormationUpdaterEventBridgeRuleState

## AMI Creation EC2 Image Builder Pipeline
Resources:
  # S3 bucket to store CIS benchmark validation results
  ImagePipelineS3:
    Type: AWS::S3::Bucket
    Properties:
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - BucketKeyEnabled: true
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      LoggingConfiguration:
        LogFilePrefix: 'access-logs'
  
  # Bucker policy for ImagePipelineS3 bucket
  ImagePipelineS3Policy:
    Type: AWS::S3::BucketPolicy
    Properties: 
      Bucket: !Ref ImagePipelineS3
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Action:
              - 's3:GetObject'
              - 's3:ListBucket'
            Effect: Allow
            Resource: 
              - !Sub "${ImagePipelineS3.Arn}/*"
              - !Sub "${ImagePipelineS3.Arn}"
            Principal: 
              AWS: !Ref AWS::AccountId
          - Action:
              - 's3:PutObject'
            Effect: Allow
            Resource: 
              - !Sub "${ImagePipelineS3.Arn}/*"
            Principal: 
              Service: logging.s3.amazonaws.com
            Condition:
              ArnLike:
                'aws:SourceArn': !GetAtt ImagePipelineS3.Arn
              StringEquals:
                'aws:SourceAccount': !Sub '${AWS::AccountId}'
          - Action:
              - 's3:PutObject'
            Effect: Deny
            Resource: !Sub "${ImagePipelineS3.Arn}/*"
            Principal: "*"
            Condition:
              ArnNotEquals:
                'aws:PrincipalArn' : !GetAtt ImageBuilderRole.Arn

  # KMS key for SNS topics
  SNStopicKey:
    Type: 'AWS::KMS::Key'
    UpdateReplacePolicy: Delete
    DeletionPolicy: Delete
    Properties:
      Description: KMS Key to encrypt SNS topics for ECS instance refresh topics
      EnableKeyRotation: true
      PendingWindowInDays: 7
      KeyPolicy:
        Version: 2012-10-17
        Statement:
          - Sid: Enable IAM User Permissions
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action: kms:*
            Resource: '*'
          - Sid: Enable EventBridge, image update reminder lambda, and ImageBuilder Permissions
            Effect: Allow
            Principal:
              Service: 'events.amazonaws.com'
              AWS:
                - !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/aws-service-role/imagebuilder.amazonaws.com/AWSServiceRoleForImageBuilder'
                - !GetAtt ImageUpdateReminderLambdaExecutionRole.Arn
            Action:
              - 'kms:Decrypt'
              - 'kms:GenerateDataKey*'
            Resource: '*'

  # SNS Topic for image builder pipeline
  ImagePipelineSNSTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: !Sub '${ImagePipelineName} Topic'
      KmsMasterKeyId: !Ref SNStopicKey

  # IAM Role for EC2 Image Builder
  ImageBuilderRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - ec2.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: /ec2/
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/EC2InstanceProfileForImageBuilder
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore

  # IAM Policy for EC2 Image Builder to access S3 bucket containing Ansible files
  ImageBuilderS3AccessPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: "Managed policy for Image builder to access S3 buckets"
      Roles:
        - !Ref ImageBuilderRole
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - s3:GetObject
              - s3:ListBucket
            Resource: 
              - !Sub 'arn:${AWS::Partition}:s3:::${AnsiblePlaybookBucket}'
              - !Sub 'arn:${AWS::Partition}:s3:::${AnsiblePlaybookBucket}/*'
          - Effect: Allow
            Action:
              - s3:PutObject
            Resource:
              - !Sub "${ImagePipelineS3.Arn}/*"

  # IAM Instance Profile for EC2 Image Builder
  ImageBuilderInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - !Ref ImageBuilderRole
  
  # EC2 Image Builder Components
  ECSAnsibleComponent:
    Type: AWS::ImageBuilder::Component
    Properties:
      Name: !Ref ComponentName
      Version: '1.0.0'
      Description: Ansible component for EC2 Image Builder
      Platform: Linux
      Data: !Sub |
        name: ExecuteAnsiblePlaybook
        description: Execute an Ansible playbook
        schemaVersion: 1.0
        phases:
          - name: build
            steps:
              - name: PartitioningVarLibDocker
                action: ExecuteBash
                inputs:
                  commands:
                  - sudo yum install -y rsync
                  - sudo mkfs.ext4 /dev/xvdf
                  - sudo mkdir -p /mnt/temp_docker
                  - sudo mount /dev/xvdf /mnt/temp_docker
                  - sudo systemctl stop docker
                  - sudo rsync -av /var/lib/docker/ /mnt/temp_docker/
                  - sudo umount /mnt/temp_docker
                  - sudo rmdir /mnt/temp_docker
                  - sudo mount /dev/xvdf /var/lib/docker
                  - sudo echo '/dev/xvdf /var/lib/docker ext4 defaults,nofail 0 0' >> /etc/fstab
                  - sudo systemctl start docker
              - name: installAnsible
                action: ExecuteBash
                inputs:
                  commands:
                  - |
                    if [ ! -f /etc/os-release ]; then
                      echo "The file /etc/os-release does not exist on this system."
                      exit 1
                    fi
                    . /etc/os-release
                    if [ "$ID" = "amzn" ]; then
                      if [ "$VERSION_ID" = "2" ]; then
                        echo "Installing Ansible on Amazon Linux 2..."
                        sudo amazon-linux-extras install ansible2 -y
                      elif [ "$VERSION_ID" = "2023" ]; then
                        echo "Installing Ansible on Amazon Linux 2023..."
                        sudo yum install ansible -y
                      else
                        echo "Unknown Amazon Linux version: $VERSION_ID"
                        exit 1
                      fi
                    else
                      echo "This system is not Amazon Linux."
                      exit 1
                    fi
              - name: CreateAnsibleFolders
                action: ExecuteBash
                inputs:
                  commands:
                  - sudo mkdir -p /tmp/ansible/roles/cis-docker-benchmark
                  - sudo mkdir /tmp/ansible/roles/cis-docker-benchmark/defaults /tmp/ansible/roles/cis-docker-benchmark/files /tmp/ansible/roles/cis-docker-benchmark/tasks
              - name: DownloadPlaybook
                action: S3Download
                inputs:
                  - source: s3://${AnsiblePlaybookBucket}/roles/cis-docker-benchmark/defaults/*
                    destination: '/tmp/ansible/roles/cis-docker-benchmark/defaults/'
                  - source: s3://${AnsiblePlaybookBucket}/roles/cis-docker-benchmark/files/*
                    destination: '/tmp/ansible/roles/cis-docker-benchmark/files/'
                  - source: s3://${AnsiblePlaybookBucket}/roles/cis-docker-benchmark/tasks/*
                    destination: '/tmp/ansible/roles/cis-docker-benchmark/tasks/'
                  - source: s3://${AnsiblePlaybookBucket}/docker-cis.yml
                    destination: '/tmp/ansible/docker-cis.yml'
              - name: InvokeAnsible
                action: ExecuteBash
                inputs:
                  commands:
                    - ansible-playbook /tmp/ansible/docker-cis.yml ${AnsiblePlaybookArguments}
              - name: DeletePlaybook
                action: ExecuteBash
                inputs:
                  commands:
                    - sudo rm -rf '/tmp/ansible'
          - name: test
            steps:
              - name: installRequirements
                action: ExecuteBash
                inputs:
                  commands:
                    - sudo yum install -y git jq
                    - sudo mkdir -p /tmp/docker-bench-security
                    - git clone https://github.com/docker/docker-bench-security.git /tmp/docker-bench-security
              - name: runDockerBench
                action: ExecuteBash
                inputs:
                  commands:
                    - cd /tmp/docker-bench-security/
                    - sudo sh docker-bench-security.sh
              - name: UploadResultsToS3
                action: S3Upload
                onFailure: Abort
                maxAttempts: 3
                inputs:
                  - source: /tmp/docker-bench-security/log/*
                    destination: s3://${ImagePipelineS3}/cis_audit/
                    expectedBucketOwner: ${AWS::AccountId}
              - name: deleteDockerBench
                action: ExecuteBash
                inputs:
                  commands:
                    - sudo yum uninstall -y git jq
                    - sudo rm -rf /tmp/docker-bench-security

  # EC2 Image Builder Recipe
  ECSAnsibleRecipe:
    Type: AWS::ImageBuilder::ImageRecipe
    Properties:
      Name: !Ref RecipeName
      Version: '1.0.0'
      Description: Image recipe for ECS Optimized Image with Ansible playbook
      Components:
        - ComponentArn: !Ref ECSAnsibleComponent
      ParentImage: !Ref LatestECSOptimizedAMI
      BlockDeviceMappings:
        - DeviceName: /dev/xvda
          Ebs:
            DeleteOnTermination: true
            Encrypted: true
            VolumeSize: !Ref RootVolumeSize
            VolumeType: !Ref RootVolumeType
        - DeviceName: /dev/xvdf
          Ebs:
            DeleteOnTermination: true
            Encrypted: true
            VolumeSize: !Ref libDockerVolumeSize
            VolumeType: !Ref libDockerVolumeType

  # EC2 Image Builder Infrastructure Configuration
  ImageBuilderInfrastructureConfig:
    Type: AWS::ImageBuilder::InfrastructureConfiguration
    Properties:
      Name: !Ref InfrastructureConfigurationName
      Description: Infrastructure Configuration for EC2 Image Builder
      InstanceProfileName: !Ref ImageBuilderInstanceProfile
      InstanceTypes:
        - !Ref InstanceType
      SnsTopicArn: !Ref ImagePipelineSNSTopic

  # EC2 Image Builder Distribution Configuration
  ImageBuilderDistributionConfig:
    Type: AWS::ImageBuilder::DistributionConfiguration
    Properties:
      Name: !Ref DistributionConfigurationName
      Description: Distribution Configuration for EC2 Image Builder
      Distributions:
        - Region: !Ref AWS::Region
          AmiDistributionConfiguration:
            Name: !Sub '${AWS::StackName}-AMI - {{ imagebuilder:buildDate }}'
            Description: CIS Docker Benchmark hardened ECS optimized image

  # EC2 Image Builder Pipeline
  ECSAnsiblePipeline:
    Type: AWS::ImageBuilder::ImagePipeline
    Properties:
      Name: !Ref ImagePipelineName
      Description: EC2 Image Builder Pipeline for ECS Optimized Image with Ansible playbook
      ImageRecipeArn: !Ref ECSAnsibleRecipe
      InfrastructureConfigurationArn: !Ref ImageBuilderInfrastructureConfig
      DistributionConfigurationArn: !Ref ImageBuilderDistributionConfig
      EnhancedImageMetadataEnabled : false
      ImageScanningConfiguration:
        ImageScanningEnabled: !Ref EnableImageScanning

## Shared Resources
  # SNS subscription to trigger Lambda function that starts instance refresh
  ImageBuilderTopicSubscription:
    Type: AWS::SNS::Subscription
    Properties: 
      Endpoint: !GetAtt StepFunctionTriggerLambda.Arn
      Protocol: lambda
      TopicArn: !Ref ImagePipelineSNSTopic

  # Lambda function that starts instance refresh Step Function
  StepFunctionTriggerLambda:
    Type: AWS::Lambda::Function
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "This Lambda does not require access to any resources in private subnets"
    Properties:
      Runtime: python3.11
      Role: !GetAtt StepFunctionTriggerLambdaExecutionRole.Arn
      Handler: index.lambda_handler
      Code:
        ZipFile: |
          import json
          import os
          import boto3
          def lambda_handler(event, context):
              """
              Gets Image Builder pipeline status and triggers Step Function upon successful release of new AMI.
              """
              # Extract the image ID from the SNS message
              sns_message = json.loads(event["Records"][0]["Sns"]["Message"])
              image_id = sns_message["outputResources"]["amis"][0]["image"]
              image_status = sns_message["state"]["status"]
              image_status_reason = sns_message["state"].get("reason")

              # prepare cluster filter tags
              tags_json = os.environ['TAGS']
              tags = json.loads(tags_json)

              if image_status == "AVAILABLE":
                  # Start the Step Function
                  step_function_arn = os.environ['SFARN']
                  step_function_input = {"image_id": image_id, "tags": tags}
                  client = boto3.client("stepfunctions")
                  response = client.start_execution(
                      stateMachineArn=step_function_arn, input=json.dumps(step_function_input)
                  )

                  # Return the Step Function execution ARN
                  return response["executionArn"]
              
              return image_status_reason
      Environment:
        Variables:
          TAGS: !Ref ClusterTags
          SFARN: !Ref StateMachine
      Layers: 
        - !Sub 'arn:aws:lambda:${AWS::Region}:017000801446:layer:AWSLambdaPowertoolsPythonV2:45'
      ReservedConcurrentExecutions: 1
      Timeout: 900

  # IAM Role for Step Machine that manages Autoscaling group instance refresh
  StepFunctionTriggerLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: /lambda/
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # IAM policy for Step Machine that manages Autoscaling group instance refresh
  StepFunctionTriggerLambdaExecutionPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: Policy for the State Machine Lambda function execution role
      Path: /lambda/
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Sid: 'lambda2Statemachine'
          Effect: Allow
          Action:
            - states:StartExecution
          Resource: !Ref StateMachine
        - Sid: 'lambda2cloudwatch'
          Effect: Allow
          Action:
            - logs:CreateLogGroup
            - logs:CreateLogStream
            - logs:PutLogEvents
          Resource:
            - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:*'
            - !Sub 'arn:${AWS::Partition}:logs:${AWS::Region}:${AWS::AccountId}:log-group:*:log-stream:*'
      Roles:
        - !Ref StepFunctionTriggerLambdaExecutionRole

  # Lambda permission for Step Machine that manages Autoscaling group instance refresh
  StepFunctionTriggerLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties: 
      Action: lambda:InvokeFunction
      FunctionName: !Ref StepFunctionTriggerLambda
      Principal: sns.amazonaws.com
      SourceAccount: !Ref AWS::AccountId
      SourceArn: !Ref ImagePipelineSNSTopic

  # Lambda that checks for a new version of Image Builder parent image
  ImageUpdateReminderLambda:
    Type: AWS::Lambda::Function
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "This Lambda does not require access to any resources in private subnets"
    Properties:
      Runtime: python3.11
      Role: !GetAtt ImageUpdateReminderLambdaExecutionRole.Arn
      Handler: index.lambda_handler
      Code:
        ZipFile: |
          import os
          import json
          from datetime import datetime
          import boto3
          from botocore.exceptions import ClientError


          def get_latest_image(region, image_pipeline_arn):
              """
              Returns the latest available image from Image Builder.
              """
              imagebuilder = boto3.client("imagebuilder", region_name=region)
              try:
                  response = imagebuilder.list_image_pipeline_images(maxResults=15, imagePipelineArn=image_pipeline_arn)
                  pipeline_response = imagebuilder.get_image_pipeline(imagePipelineArn=image_pipeline_arn)
                  image_recipe_arn = pipeline_response.get('imagePipeline').get('imageRecipeArn')
                  recipe_response = imagebuilder.get_image_recipe(imageRecipeArn=image_recipe_arn)
              except (
                  imagebuilder.exceptions.ServiceException,
                  imagebuilder.exceptions.ClientException,
                  imagebuilder.exceptions.ServiceUnavailableException,
                  imagebuilder.exceptions.InvalidRequestException,
                  imagebuilder.exceptions.InvalidPaginationTokenException,
                  imagebuilder.exceptions.ForbiddenException,
                  imagebuilder.exceptions.CallRateLimitExceededException,
                  ClientError,
                  Exception) as error:
                  raise Exception(f"Error retrieving latest Image Builder image: {str(error)}")
              image_summary_list = response["imageSummaryList"]
              if not image_summary_list:
                  return "No available images found"
              available_images = [image for image in image_summary_list if image['state']['status'] == 'AVAILABLE']
              latest_image = max(available_images, key=lambda x: x["version"])
              current_pipeline_parent_ami = recipe_response.get('imageRecipe').get('parentImage')
              return latest_image, current_pipeline_parent_ami

          def get_image_parameter_info(ssm_parameter_name, region):
              """
              Returns latest modified date of SSM parameter containing parent image information
              """
              ssm = boto3.client("ssm", region_name=region)
              try:
                  response = ssm.get_parameters(Names=[ssm_parameter_name])
              except (
                  ssm.exceptions.InternalServerError,
                  ssm.exceptions.InvalidKeyId,
                  ssm.exceptions.ParameterNotFound,
                  ssm.exceptions.ParameterVersionNotFound,
                  ClientError,
                  Exception
              ) as error:
                  raise Exception(
                      f"Error retrieving SSM parameter {ssm_parameter_name}: {str(error)}"
                  )

              if not response["Parameters"]:
                  raise Exception(f"SSM parameter {ssm_parameter_name} not found")
              parameter_info = response["Parameters"][0]

              return parameter_info


          def get_parent_image_info(region, stack_name):
              """
              Returns the current StackVersion from the CloudFormation stack output.
              """
              cloudformation = boto3.client("cloudformation", region_name=region)
              try:
                  stacks = []
                  next_token = None
                  while True:
                      if next_token:
                          response = cloudformation.describe_stacks(
                              StackName=stack_name, NextToken=next_token
                          )
                      else:
                          response = cloudformation.describe_stacks(StackName=stack_name)
                      stacks.extend(response["Stacks"])
                      next_token = response.get('NextToken')
                      if not next_token:
                          break
              except (ClientError,
                      Exception) as error:
                  raise Exception(f"Stack does not exist: {str(error)}")

              stack_parameters = response["Stacks"][0]["Parameters"]
              latest_ecs_optimized_ami = None
              for parameter in stack_parameters:
                  if parameter["ParameterKey"] == "LatestECSOptimizedAMI":
                      latest_ecs_optimized_ami = parameter["ParameterValue"]
              
              return latest_ecs_optimized_ami

          def publish_sns_message(message, topic_arn):
              """
              Publishes a SNS message containing information regarding EC2 Image Builder parent image.
              """
              # Get boto3 client
              sns = boto3.client('sns')

              try:
                  response = sns.publish(
                      TopicArn=topic_arn,
                      Message=json.dumps(message,indent=2)
                  )
              except (sns.exceptions.InvalidParameterException,
                      sns.exceptions.InvalidParameterValueException,
                      sns.exceptions.InternalErrorException,
                      sns.exceptions.NotFoundException,
                      sns.exceptions.EndpointDisabledException,
                      sns.exceptions.PlatformApplicationDisabledException,
                      sns.exceptions.AuthorizationErrorException,
                      sns.exceptions.KMSDisabledException,
                      sns.exceptions.KMSInvalidStateException,
                      sns.exceptions.KMSNotFoundException,
                      sns.exceptions.KMSOptInRequired,
                      sns.exceptions.KMSThrottlingException,
                      sns.exceptions.KMSAccessDeniedException,
                      sns.exceptions.InvalidSecurityException,
                      sns.exceptions.ValidationException,
                      ClientError,
                      Exception) as error:
                  raise Exception(f"Stack does not exist: {str(error)}")
              
              return response

          def lambda_handler(event, context):
              """
              Lambda function entry point.
              """
              # Get environment variables
              region = os.environ.get("REGION", "")
              stack_name = os.environ.get("STACK_NAME", "")
              image_pipeline_arn = os.environ.get("IMAGE_PIPELINE_ARN", "")
              sns_topic_arn = os.environ.get("SNS_Topic_ARN", "")

              # Get the latest image from Image Builder
              latest_image, parent_image_id = get_latest_image(region, image_pipeline_arn)
              image_creation_date = datetime.strptime(
                  latest_image["dateCreated"], "%Y-%m-%dT%H:%M:%S.%f%z"
              )

              # Get the last modified date of the SSM parameter
              ssm_parameter_name = get_parent_image_info(region, stack_name)
              parameter_info = get_image_parameter_info(ssm_parameter_name, region)
              ssm_last_modified_date = parameter_info["LastModifiedDate"]

              # Compare dates
              if ssm_last_modified_date > image_creation_date:
                  message = {
                      "Message": "A new version of the parent image for your piprline is available",
                      "Parent image SSM Parameter path": parameter_info['Name'],
                      "New parent image AMI ID": parameter_info['Value'],
                      "Parent image last modified date": ssm_last_modified_date.strftime('%Y-%m-%dT%H:%M:%S.%f%z'),
                      "Current parent image AMI ID": parent_image_id,
                      "Image Pipeline last image build date": image_creation_date.strftime('%Y-%m-%dT%H:%M:%S.%f%z'),
                      "Image Pipeline ARN": image_pipeline_arn
                  }
                  response = publish_sns_message(message, sns_topic_arn)
              else:
                  message = {
                      "Message": "Parent image is up to date",
                      "Parent image SSM Parameter path": parameter_info['Name'],
                      "New parent image AMI ID": parameter_info['Value'],
                      "Parent image last modified date": ssm_last_modified_date.strftime('%Y-%m-%dT%H:%M:%S.%f%z'),
                      "Current parent image AMI ID": parent_image_id,
                      "Image Pipeline last image build date": image_creation_date.strftime('%Y-%m-%dT%H:%M:%S.%f%z'),
                      "Image Pipeline ARN": image_pipeline_arn
                  }
                  response = publish_sns_message(message, sns_topic_arn)
              # Return response
              return response
      Environment:
        Variables:
          REGION: !Ref AWS::Region
          STACK_NAME: !Ref AWS::StackName
          IMAGE_PIPELINE_ARN: !Ref ECSAnsiblePipeline
          SNS_Topic_ARN: !Ref ImageUpdateReminderTopic
      Layers: 
        - !Sub 'arn:aws:lambda:${AWS::Region}:017000801446:layer:AWSLambdaPowertoolsPythonV2:45'
      ReservedConcurrentExecutions: 1
      Timeout: 900

  # IAM Role for Lambda that checks for a new version of Image Builder parent image
  ImageUpdateReminderLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: /lambda/
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # IAM policy for Lambda that checks for a new version of Image Builder parent image
  ImageUpdateReminderLambdaExecutionPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: Policy for the State Machine Lambda function execution role
      Path: /lambda/
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Sid: 'lambda2imagebuilder'
          Effect: Allow
          Action:
            - imagebuilder:ListImagePipelineImages
            - imagebuilder:GetImagePipeline
            - imagebuilder:GetImageRecipe
          Resource: 
            - !Ref ECSAnsiblePipeline
            - !Sub 'arn:${AWS::Partition}:imagebuilder:${AWS::Region}:${AWS::AccountId}:image/*'
            - !Join
              - ''
              - - !Sub 'arn:${AWS::Partition}:imagebuilder:${AWS::Region}:${AWS::AccountId}:image-recipe/'
                - !Select [1, !Split ['/',!Ref ECSAnsibleRecipe]]
                - '/*'
        - Sid: 'lambda2cloudformation'
          Effect: Allow
          Action:
            - cloudformation:DescribeStacks
          Resource:
            - !Ref AWS::StackId
        - Sid: 'lambda2ssm'
          Effect: Allow
          Action:
            - ssm:GetParameters
          Resource:
            - !Sub 'arn:${AWS::Partition}:ssm:${AWS::Region}::parameter/aws/service/ecs/optimized-ami/*'
        - Sid: 'lambda2sns'
          Effect: Allow
          Action:
            - sns:Publish
          Resource:
            - !Ref ImageUpdateReminderTopic
        - Sid: 'lambda2kms'
          Effect: Allow
          Action:
            - 'kms:Decrypt'
            - 'kms:GenerateDataKey*'
          Resource: !GetAtt SNStopicKey.Arn
      Roles:
        - !Ref ImageUpdateReminderLambdaExecutionRole

  # Lambda permission for EventBridge rule that trigers the Lambda that checks for a new version of Image Builder parent image
  ImageUpdateReminderLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties: 
      Action: lambda:InvokeFunction
      FunctionName: !Ref ImageUpdateReminderLambda
      Principal: events.amazonaws.com
      SourceAccount: !Ref AWS::AccountId
      SourceArn: !GetAtt ImageUpdateReminderEventBridgeRule.Arn

  # IAM Role for EventBridge rule that trigers the Lambda that checks for a new version of Image Builder parent image
  EventBridgeLambdaRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Principal:
              Service:
                - 'events.amazonaws.com'
            Action:
              - 'sts:AssumeRole'
      Path: /events/

  # IAM Policy for EventBridge rule that trigers the Lambda that checks for a new version of Image Builder parent image
  EventBridgeLambdaPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: Policy for EventBridge Lambda role
      Path: /events/
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - lambda:InvokeFunction
            Resource: !GetAtt ImageUpdateReminderLambda.Arn
      Roles:
        - !Ref EventBridgeLambdaRole

  # EventBridge rule that triggers the Lambda that checks for a new version of Image Builder parent image
  ImageUpdateReminderEventBridgeRule:
    Type: AWS::Events::Rule
    Properties:
      Description: Rule that triggers CloudFormation Lambda updater pipeline every week
      ScheduleExpression: "cron(0 0 ? * SUN *)"
      Targets: 
        - Arn: !GetAtt ImageUpdateReminderLambda.Arn
          Id: 'ImageUpdateReminderLambdaTarget'
      RoleArn: !GetAtt EventBridgeLambdaRole.Arn
      State: !Ref CloudFormationUpdaterEventBridgeRuleState

  # SNS Topic recieving Lambda response that checks for a new version of Image Builder parent image 
  ImageUpdateReminderTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: 'ImageUpdateReminderTopic'
      KmsMasterKeyId: !Ref SNStopicKey

  # SNS Topic policy for SNS Topic recieving Lambda response that checks for a new version of Image Builder parent image 
  ImageUpdateReminderSNSTopicPolicy:
    Type: AWS::SNS::TopicPolicy
    Properties: 
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Sid: __default_statement_ID
          Effect: Allow
          Principal:
            AWS: !Ref AWS::AccountId
          Action:
            - SNS:GetTopicAttributes
            - SNS:SetTopicAttributes
            - SNS:AddPermission
            - SNS:RemovePermission
            - SNS:DeleteTopic
            - SNS:Subscribe
            - SNS:ListSubscriptionsByTopic
            - SNS:Publish
          Resource: !Ref ImageUpdateReminderTopic
          Condition:
            StringEquals:
              AWS:SourceOwner: !Ref AWS::AccountId
        - Sid: lambda_rule_access
          Principal:
            Service:
              - lambda.amazonaws.com
          Effect: Allow
          Action:
            - sns:Publish
          Resource: !Ref ImageUpdateReminderTopic
      Topics: 
        - !Ref ImageUpdateReminderTopic

## Auto Instance replace resources
  # IAM Role for Lambda function that gets a list of ECS clusters Autoscaling groups
  ASGLambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - 'lambda.amazonaws.com'
            Action:
              - 'sts:AssumeRole'
      Path: /lambda/
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # IAM policy for Lambda function that gets a list of ECS clusters Autoscaling groups
  ASGLambdaExecutionPolicy:
    Type: 'AWS::IAM::ManagedPolicy'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W13
            reason: 'Actions in policy require Resource="*", view https://docs.aws.amazon.com/service-authorization/latest/reference/reference_policies_actions-resources-contextkeys.html'
    Properties:
      Description: Policy for the AutoScaling group finder Lambda function execution role
      Path: '/lambda/'
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - 'ecs:ListClusters'
              - 'autoscaling:DescribeAutoScalingGroups'
              - 'ec2:DescribeLaunchTemplates'
            Resource: '*'
          - Effect: Allow
            Action:
              - 'ecs:DescribeClusters'
              - 'ecs:DescribeCapacityProviders'
            Resource:
              - !Sub 'arn:${AWS::Partition}:ecs:${AWS::Region}:${AWS::AccountId}:cluster/*'
              - !Sub 'arn:${AWS::Partition}:ecs:${AWS::Region}:${AWS::AccountId}:capacity-provider/*'
          - Effect: Allow
            Action: 'ec2:CreateLaunchTemplateVersion'
            Resource: !Sub 'arn:${AWS::Partition}:ec2:${AWS::Region}:${AWS::AccountId}:launch-template/*'
      Roles: 
        - !Ref ASGLambdaExecutionRole

  # Lambda function that gets a list of ECS clusters Autoscaling groups
  AutoScalingGroupUpdaterLambda:
    Type: AWS::Lambda::Function
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "This Lambda does not require access to any resources in private subnets"
    Properties:
      Runtime: python3.11
      Role: !GetAtt ASGLambdaExecutionRole.Arn
      Handler: index.lambda_handler
      Code:
        ZipFile: |
          import boto3
          def list_clusters(ecs_client):
              """
              Lists all ECS clusters.

              Args:
                  ecs: An initialized Boto3 ECS client.

              Returns:
                  A list of cluster ARNs.
              """
              paginator = ecs_client.get_paginator("list_clusters")
              clusters = []
              for page in paginator.paginate():
                  clusters.extend(page["clusterArns"])
              return clusters


          def get_capacity_providers(ecs_client, clusters, required_tags):
              """
              Retrieves capacity providers for clusters with the required tags.

              Args:
                  ecs: An initialized Boto3 ECS client.
                  cluster_arns: A list of ECS cluster ARNs.
                  tags: A list of tags to filter clusters. If empty, returns capacity providers for all clusters.

              Returns:
                  A list of capacity provider ARNs.
              """
              required_tags_set = (
                  {(tag["Key"], tag["Value"]) for tag in required_tags} if required_tags else None
              )

              def has_required_tags(cluster_tags):
                  if not required_tags_set:
                      return True
                  cluster_tags_set = {(tag["key"], tag["value"]) for tag in cluster_tags}
                  return required_tags_set.issubset(cluster_tags_set)

              capacity_providers = []

              for cluster_arn in clusters:
                  try:
                      cluster_info = ecs_client.describe_clusters(
                          clusters=[cluster_arn], include=["TAGS"]
                      )
                      cluster = cluster_info["clusters"][0]
                      cluster_tags = cluster["tags"]

                      if has_required_tags(cluster_tags):
                          cluster_capacity_providers = cluster["capacityProviders"]
                          filtered_capacity_providers = [
                              cp
                              for cp in cluster_capacity_providers
                              if cp not in ["FARGATE", "FARGATE_SPOT"]
                          ]
                          capacity_providers.extend(filtered_capacity_providers)
                  except Exception as e:
                      print(f"Error getting capacity providers for cluster {cluster_arn}: {e}")

              return capacity_providers


          def get_autoscaling_groups(ecs_client, capacity_providers):
              """
              Gets the auto-scaling groups associated with the capacity providers.

              Args:
                  ecs: An initialized Boto3 ECS client.
                  capacity_providers: A list of capacity provider ARNs.

              Returns:
                  A list of dictionaries containing auto-scaling group information.
              """
              autoscaling_groups = []
              for capacity_provider in capacity_providers:
                  provider_info = ecs_client.describe_capacity_providers(
                      capacityProviders=[capacity_provider], include=["TAGS"]
                  )
                  provider = provider_info["capacityProviders"][0]
                  if "autoScalingGroupProvider" in provider:
                      asg_provider = provider["autoScalingGroupProvider"]
                      if asg_provider["managedScaling"]["status"] == "ENABLED":
                          autoscaling_group_arn = asg_provider["autoScalingGroupArn"]
                          autoscaling_group_name = autoscaling_group_arn.split("/")[-1]
                          autoscaling_group = {
                              "AutoScalingGroupArn": autoscaling_group_arn,
                              "AutoScalingGroupName": autoscaling_group_name,
                          }
                          autoscaling_groups.append(autoscaling_group)
              return autoscaling_groups


          def update_launch_templates(autoscaling_client, autoscaling_groups, image_id):
              """
              Updates the launch templates of the auto-scaling groups with the provided image ID.

              Args:
                  autoscaling: An initialized Boto3 Auto Scaling client.
                  autoscaling_groups: A list of dictionaries containing auto-scaling group information.
                  image_id: The image ID to be used in the updated launch templates.

              Returns:
                  A list of dictionaries containing the updated auto-scaling group information.
              """
              ec2_client = boto3.client("ec2")
              processed_launch_templates = set()

              for autoscaling_group in autoscaling_groups:
                  group_name = autoscaling_group["AutoScalingGroupName"]
                  try:
                      group_info = autoscaling_client.describe_auto_scaling_groups(
                          AutoScalingGroupNames=[group_name]
                      )
                      launch_template = group_info["AutoScalingGroups"][0]["LaunchTemplate"]
                      launch_template_id = launch_template["LaunchTemplateId"]
                      launch_template_version = launch_template["Version"]
                      autoscaling_group["LaunchTemplateIdSetting"] = launch_template_version
                      autoscaling_group["LaunchTemplateId"] = launch_template_id

                      if launch_template_id not in processed_launch_templates:
                          new_launch_template_response = (
                              ec2_client.create_launch_template_version(
                                  LaunchTemplateId=launch_template_id,
                                  SourceVersion=str(launch_template_version),
                                  LaunchTemplateData={
                                      "ImageId": image_id,
                                  },
                              )
                          )
                          new_launch_template_version_number = str(
                              new_launch_template_response["LaunchTemplateVersion"][
                                  "VersionNumber"
                              ]
                          )

                          autoscaling_group[
                              "LaunchTemplateVersion"
                          ] = new_launch_template_version_number

                          processed_launch_templates.add(launch_template_id)
                      else:
                          launch_template_info = ec2_client.describe_launch_templates(
                              LaunchTemplateIds=[launch_template_id]
                          )
                          latest_version_number = str(
                              launch_template_info["LaunchTemplates"][0]["LatestVersionNumber"]
                          )
                          autoscaling_group["LaunchTemplateVersion"] = latest_version_number

                  except Exception as e:
                      print(
                          f"Error updating launch template for Auto Scaling group {group_name}: {e}"
                      )

              return autoscaling_groups


          def lambda_handler(event, context):
              """
              Main Lambda function handler.

              Args:
                  event: A dictionary containing the event data passed to the Lambda function.
                  context: The Lambda function execution context.

              Returns:
                  A list of dictionaries containing the updated auto-scaling group information.
              """
              ecs = boto3.client("ecs")
              autoscaling = boto3.client("autoscaling")

              clusters = list_clusters(ecs)
              capacity_providers = get_capacity_providers(ecs, clusters, event.get("tags", []))
              autoscaling_groups = get_autoscaling_groups(ecs, capacity_providers)

              image_id = event["image_id"]
              updated_autoscaling_groups = update_launch_templates(
                  autoscaling, autoscaling_groups, image_id
              )

              autoscaling_groups = [
                  {
                      "AutoScalingGroupArn": asg["AutoScalingGroupArn"],
                      "AutoScalingGroupName": asg["AutoScalingGroupName"],
                      "LaunchTemplateVersion": asg["LaunchTemplateVersion"],
                      "LaunchTemplateId": asg["LaunchTemplateId"],
                      "LaunchTemplateIdSetting": asg["LaunchTemplateIdSetting"],
                  }
                  for asg in updated_autoscaling_groups
              ]

              return autoscaling_groups
      Description: Lambda function to find ASGs and update Launch Templates
      Layers: 
        - !Sub 'arn:aws:lambda:${AWS::Region}:017000801446:layer:AWSLambdaPowertoolsPythonV2:45'
      ReservedConcurrentExecutions: 3
      Timeout: 900
      TracingConfig:
        Mode: Active

  # IAM Role for Lambda function that refreshes Autoscaling group instances
  InstanceRefreshLambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Path: /lambda/
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole

  # IAM policy for Lambda function that refreshes Autoscaling group instances
  InstanceRefreshLambdaExecutionPolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: Policy for the Autoscaling Group instance refresh Lambda function execution role
      Path: /lambda/
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - autoscaling:Describe*
              - ec2:DescribeLaunchTemplates
              - ec2:RunInstances
            Resource: '*'
          - Effect: Allow
            Action:
              - autoscaling:StartInstanceRefresh
              - autoscaling:UpdateAutoScalingGroup
            Resource:
              - !Sub 'arn:${AWS::Partition}:autoscaling:${AWS::Region}:${AWS::AccountId}:autoScalingGroup:*:autoScalingGroupName/*'
          - Effect: Allow
            Action: 'ec2:CreateLaunchTemplateVersion'
            Resource: !Sub 'arn:${AWS::Partition}:ec2:${AWS::Region}:${AWS::AccountId}:launch-template/*'
          - Effect: Allow
            Action:
              - iam:PassRole
            Resource:
              - !Sub 'arn:${AWS::Partition}:iam::${AWS::AccountId}:role/*'
            Condition:
              StringEquals:
                iam:PassedToService:
                  - ec2.amazonaws.com
      Roles:
        - !Ref InstanceRefreshLambdaExecutionRole

  # Lambda function refreshing Autoscaling group instances
  AutoScalingGroupInstanceRefreshLambda:
    Type: AWS::Lambda::Function
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "This Lambda does not require access to any resources in private subnets"
          - id: W92
            reason: "Number of concurrent executions is controlled by state machine"
    Properties:
      Runtime: python3.11
      Role: !GetAtt InstanceRefreshLambdaExecutionRole.Arn
      Handler: index.lambda_handler
      Code:
        ZipFile: |
          import logging
          import boto3

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)


          def update_capacity_provider_launch_template(event, context):
              """
              Update the launch template version of an Auto Scaling group and initiate an instance refresh.

              :param event: An event object containing the necessary information about the Auto Scaling group and launch template.
              :param context: The AWS Lambda context object (not used in this function).
              :return: A dictionary containing the Auto Scaling group name, ARN, and the instance refresh ID.
              """
              autoscaling = boto3.client("autoscaling")

              # Retrieve information from the event
              group_name = event["AutoScalingGroupName"]
              launch_template_id = event["LaunchTemplateId"]
              new_launch_template_version_number = event["LaunchTemplateVersion"]
              launch_template_id_settings = event["LaunchTemplateIdSetting"]

              auto_rollback = True

              if launch_template_id_settings in ["$Latest", "$Default"]:
                  auto_rollback = False

              try:
                  # Start an instance refresh to rollout the new image and update instances
                  instance_refresh_response = autoscaling.start_instance_refresh(
                      AutoScalingGroupName=group_name,
                      Strategy="Rolling",
                      DesiredConfiguration={
                          "LaunchTemplate": {
                              "LaunchTemplateId": launch_template_id,
                              "Version": new_launch_template_version_number,
                          }
                      },
                      Preferences={
                          "MinHealthyPercentage": 80,
                          "SkipMatching": False,
                          "AutoRollback": auto_rollback,
                          "ScaleInProtectedInstances": "Wait",
                          "StandbyInstances": "Wait",
                      },
                  )

                  response_dict = {
                      "autoscaling_group_name": group_name,
                      "autoscaling_group_arn": event["AutoScalingGroupArn"],
                      "instance_refresh_id": instance_refresh_response["InstanceRefreshId"],
                  }

                  logger.info(f"Successfully started instance refresh: {response_dict}")
                  return response_dict
              except Exception as e:
                  logger.error(f"Failed to start instance refresh: {str(e)}")
                  raise


          def lambda_handler(event, context):
              """
              Lambda function handler to update the capacity provider's launch template and initiate an instance refresh.

              :param event: An event object containing the necessary information about the Auto Scaling group and launch template.
              :param context: The AWS Lambda context object (not used in this function).
              :return: A dictionary containing the input for the next Lambda function within a Step Function.
              """
              try:
                  response_dict = update_capacity_provider_launch_template(event, context)

                  # Format output for use in another Lambda function within a Step Function
                  output = {"input": response_dict}

                  return output
              except Exception as e:
                  logger.error(f"Error in lambda_handler: {str(e)}")
                  raise
      Description: Lambda function to refresh ASG instances.
      Layers: 
        - !Sub 'arn:aws:lambda:${AWS::Region}:017000801446:layer:AWSLambdaPowertoolsPythonV2:45'
      Timeout: 900
      TracingConfig:
        Mode: Active

  # State machine that gathers Autoscaling group information and triggers an instance refresh
  StateMachine:
    Type: 'AWS::StepFunctions::StateMachine'
    Properties:
      StateMachineName: ProcessAutoscalingGroupsStateMachine
      DefinitionString: !Sub |
        {
          "StartAt": "GatheringClusterInformation",
          "States": {
            "GatheringClusterInformation": {
              "Type": "Task",
              "Resource": "${AutoScalingGroupUpdaterLambda.Arn}",
              "Next": "ProcessAutoscalingGroups"
            },
            "ProcessAutoscalingGroups": {
              "Type": "Map",
              "ItemsPath": "$",
              "Parameters": {
                "AutoScalingGroupArn.$": "$$.Map.Item.Value.AutoScalingGroupArn",
                "AutoScalingGroupName.$": "$$.Map.Item.Value.AutoScalingGroupName",
                "LaunchTemplateVersion.$": "$$.Map.Item.Value.LaunchTemplateVersion",
                "LaunchTemplateId.$": "$$.Map.Item.Value.LaunchTemplateId",
                "LaunchTemplateIdSetting.$": "$$.Map.Item.Value.LaunchTemplateIdSetting"
              },
              "Iterator": {
                "StartAt": "ASGInstanceRefresh",
                "States": {
                  "ASGInstanceRefresh": {
                    "Type": "Task",
                    "Resource": "${AutoScalingGroupInstanceRefreshLambda.Arn}",
                    "Next": "Done"
                  },
                  "Done": {
                    "Type": "Succeed"
                  }
                }
              },
              "Next": "DoneAll"
            },
            "DoneAll": {
              "Type": "Succeed"
            }
          }
        }
      RoleArn: !GetAtt StateMachineRole.Arn

  # IAM Role for State machine that gathers Autoscaling group information and triggers an instance refresh
  StateMachineRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - states.amazonaws.com
            Action: 'sts:AssumeRole'
      Path: /states/

  # IAM policy for State machine that gathers Autoscaling group information and triggers an instance refresh
  StateMachinePolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: Policy for the State Machine refreshing ASG instances
      Path: /stepfunction/
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - lambda:InvokeFunction
            Resource:
              - !GetAtt AutoScalingGroupUpdaterLambda.Arn
              - !GetAtt AutoScalingGroupInstanceRefreshLambda.Arn
      Roles:
        - !Ref StateMachineRole

  # IAM Role for EventBridge rule monitoring instance refresh state
  EventBridgeSNSTopicRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: 'Allow'
            Principal:
              Service:
                - 'events.amazonaws.com'
            Action:
              - 'sts:AssumeRole'
      Path: /events/

  # IAM policy for EventBridge rule monitoring instance refresh state
  EventBridgePolicy:
    Type: AWS::IAM::ManagedPolicy
    Properties:
      Description: Policy for EventBridge SNS Topic role
      Path: /events/
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - sns:Publish
            Resource: !Ref InstanceRefreshSNSTopic
      Roles:
        - !Ref EventBridgeSNSTopicRole

  # EventBridge rule monitoring instance refresh state
  InstanceRefreshEventRule:
    Type: 'AWS::Events::Rule'
    Properties:
      Description: 'Event rule to filter Auto Scaling instance refresh events'
      EventPattern:
        source:
          - 'aws.autoscaling'
        detail-type:
          - 'EC2 Auto Scaling Instance Refresh Succeeded'
          - 'EC2 Auto Scaling Instance Refresh Failed'
          - 'EC2 Auto Scaling Instance Refresh Cancelled'
      State: 'ENABLED'
      Targets:
        - Arn: !Ref InstanceRefreshSNSTopic
          Id: 'InstanceRefreshSNSTarget'
      RoleArn: !GetAtt EventBridgeSNSTopicRole.Arn

  # SNS topic recieving information from EventBridge rule monitoring instance refresh state
  InstanceRefreshSNSTopic:
    Type: AWS::SNS::Topic
    Properties:
      DisplayName: 'InstanceRefreshAlert'
      KmsMasterKeyId: !Ref SNStopicKey

  # SNS topic policy for SNS topoc recieving information from EventBridge rule monitoring instance refresh state
  InstanceRefreshSNSTopicPolicy:
    Type: AWS::SNS::TopicPolicy
    Properties: 
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Sid: __default_statement_ID
          Effect: Allow
          Principal:
            AWS: !Ref AWS::AccountId
          Action:
            - SNS:GetTopicAttributes
            - SNS:SetTopicAttributes
            - SNS:AddPermission
            - SNS:RemovePermission
            - SNS:DeleteTopic
            - SNS:Subscribe
            - SNS:ListSubscriptionsByTopic
            - SNS:Publish
          Resource: !Ref InstanceRefreshSNSTopic
          Condition:
            StringEquals:
              AWS:SourceOwner: !Ref AWS::AccountId
        - Sid: EventBridge_rule_access
          Principal:
            Service:
              - events.amazonaws.com
          Effect: Allow
          Action:
            - sns:Publish
          Resource: !Ref InstanceRefreshSNSTopic
      Topics: 
        - !Ref InstanceRefreshSNSTopic


Outputs:
  ImagePipelineArn:
    Description: EC2 Image Builder Pipeline Arn
    Value: !Ref ECSAnsiblePipeline

  ImageUpdateReminderSNSTopicArn:
    Description: Arn of SNS topic that sends out base image update reminders
    Value: !Ref ImageUpdateReminderTopic

  InstanceRefreshSNSTopicArn:
    Description: Arn of the SNS topic that reports autoscaling instance refresh status
    Value: !Ref InstanceRefreshSNSTopic

  StateMachineArn:
    Description: Arn of the created state machine
    Value: !Ref StateMachine